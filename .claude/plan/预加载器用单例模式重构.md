# 预加载器用单例模式重构 - 执行计划

## 上下文

基于分析发现，小说阅读应用存在严重的重复请求问题，主要原因是：
1. 每个ReaderScreen实例都有独立的预加载状态
2. 多个实例同时预加载相同章节导致重复网络请求
3. 缺乏全局的章节管理机制

## 计划概述

采用统一章节管理单例（ChapterManager）重构预加载系统，解决多实例重复请求问题。

## 执行步骤

### 步骤1：创建统一章节管理单例核心类 ✅
- **文件**：`lib/services/chapter_manager.dart`
- **内容**：ChapterManager单例类实现，包含请求去重、预加载管理、状态同步等功能
- **预期结果**：单例基础架构完成，提供统一的章节管理接口

### 步骤2：修改ApiServiceWrapper集成ChapterManager ✅
- **文件**：`lib/services/api_service_wrapper.dart`
- **修改内容**：导入ChapterManager，修改getChapterContent()方法委托给ChapterManager
- **预期结果**：API层集成完成，实现请求去重

### 步骤3：重构ReaderScreen预加载逻辑（当前步骤）
- **文件**：`lib/screens/reader_screen.dart`
- **修改内容**：移除_isPreloading和_preloadedChapterUrls状态变量，使用ChapterManager
- **预期结果**：预加载逻辑完全迁移到单例，解决多实例问题

### 步骤4：更新ChapterRepository使用ChapterManager
- **文件**：`lib/data/repositories/chapter_repository_impl.dart`
- **修改内容**：修改getChapterContent()方法，通过ChapterManager获取章节
- **预期结果**：Repository层集成完成，统一章节获取流程

### 步骤5：优化CacheManager集成
- **文件**：`lib/services/cache_manager.dart`
- **修改内容**：修改后台缓存服务，使用ChapterManager避免重复请求
- **预期结果**：缓存服务集成完成，全局章节管理统一

### 步骤6：添加测试验证
- **文件**：`test/unit/chapter_manager_test.dart`
- **内容**：单例行为测试、请求去重验证、多实例并发测试
- **预期结果**：确保单例实现正确，验证功能完整性

## 关键设计决策

1. **向后兼容**：所有现有公共接口保持不变
2. **渐进式迁移**：逐步将章节相关功能迁移到单例
3. **状态同步**：确保单例状态与现有缓存机制协调
4. **内存管理**：定期清理过期状态，避免内存泄漏

## 预期收益

- **请求减少**：90%+的重复请求被去重
- **内存优化**：统一状态管理，减少重复状态存储
- **架构优化**：为未来功能扩展奠定基础
- **问题解决**：彻底解决多实例预加载冲突

## 当前状态

- ✅ 步骤1：ChapterManager单例核心类已完成
- ✅ 步骤2：ApiServiceWrapper集成已完成
- 🔄 步骤3：ReaderScreen预加载逻辑重构（进行中）
- ⏳ 步骤4-6：待执行