# 框架选择：
前端采用 vue3
用 docker-compose 部署

# 约束：
前端用 typescript 和 eslint 进行格式验证

# 结构
前端服务直接和dify进行通信和交互，基本上就是 workflow API ,需要配置下API的token和服务地址

# 数据
刚开始就保存到 web 浏览器本地就行了

# 其他
* 前端页面只在手机上使用，部署后，可以在局域网内打开来进行使用
 
# 文生图实现逻辑
1. 首先在 backend/text2img 下添加 comfyui api 的 json ，然后在 docker-compose 的 backend 环境变量中，指定文生图的 json 相对路径
2. 提供一个 API 接口 【开始配图】，请求参数是： 
novel_content： 需要插入图片的小说内容
roles： 出场角色信息
require： 配图要求
chapter_id: 章节ID，唯一标识章节

无返回数据
3. 提供再提供一个 API 接口 【获取文章配图】，请求参数是：
chapter_id: 章节ID，唯一标识章节

返回数据：
当配图还没有生成完成的时候，返回图片生成中

配图生成完成，就返回以下列表
[
    {
        index:xx 插入在第 index 段的后面
        img_url: http://host/img_url 图片的地址
    }
]

4. 关于生图逻辑的详细实现：
在收到生图请求的时候，首先把 文章内容，角色信息，要求 发送给 dify 的一个工作流，这个工作流会返回以下列表：
[
{
    index:xx 插入的段落位置，
    img_prompt: 提示词信息
}
]
收到生成的提示词之后，再调用 comfyui 生成图片。 comfyui 生成图片需要时间，如果用户请求结果，那么就判断下 comfyui 所有的图片任务是不是都生成好了。

如果都生成好了，那么就生成返回结果给用户

# 角色卡图片生成

人物卡需要以下（文生图）提示词固定：
1. 面部描写
2. 身材描写

添加这两个字段，在人物卡编辑页面，显示这两个提示词内容，增加一个按钮【重新生成文生图提示词】 ，点击之后请求 dify ,发送信息：
roles 当前角色卡的面部描写和身材描写的组合信息，
cmd : “角色卡提示词描写”

返回  face_prompts 和 body_prompts ，保存入角色卡信息中


人物卡图像生成：
backend 提供一个接口，请求参数
{
    role_id: 人物卡id 
    roles: 人物卡设定信息
    user_input: 用户要求
}
backend 请求 dify ，把 roles 和 user_input 上传 cmd 写 “拍照”，dify 返回以下信息：
{
    "content":[
        "prompt1","prompt2"
    ]
}
逐个把 提示词发送给 comfyui 生成图像。

再提供一个查看图集的接口,请求参数：
{
    role_id: 人物卡 id 
}
返回：
[
    "img_url"
]

app 端可以用 img_url 访问图片，也就是 /text2img/image/{filename} 这个接口的实现

再一个接口是，从图集中删除
上传参数是：
{
    role_id:xx,
    img_url: 刚才收到的 url 
}
效果是从角色图集中删除这个图片

最后一个接口，再生成几张：
{
    img_url: 刚才的url，
    count: n 再生成n张
}
逻辑是： 查询这个图片的生成提示词，再生成n张图片，加入到这个角色的图集中。 

在架构设计上，任何一个生成的图片都有对应的提示词。


novel_app 看了图片需要缓存到本地，如果本地已经有图了，那么就用本地的图片， 在设置中添加一个删除图片缓存和记录图片占用空间的功能，点击后可以清空缓存

人物卡管理页面，左上角显示人物图集的第一张图，点击后进入图集查看页面，点击后进入图集浏览页面，可以左右滑动查看图集，在下方有3个功能：
1. 删除功能， 删除本地的缓存同时请求 backend 从图集中删除图片
2. 多来几张，点击后用户输入需要再来几张，请求 backend 再生成一些，请求完之后提示：需要等待图片生成，等生成好之后，再进入图集可以查看最新的图片。
3. 置顶，这张图作为图集首张图，一个图集只有一个图可以置顶，不能置顶多个图：置顶的时候把当前图集中其他图取消置顶，然后把当前图片设为置顶

图集排序：越新的图排越前面